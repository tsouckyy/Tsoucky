# -*- coding: utf-8 -*-
"""Tsouckyy

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VasZ9Z_nmkNXtgBAw5Tu7J2T5gr-UOU4
"""

import json
import os
import unicodedata
import math
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
import time
from datetime import datetime, timedelta
from fuzzywuzzy import process

# Fonction pour effacer l'écran (utile pour rendre l'affichage plus propre)
def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

# Fonction pour afficher le design "Tsoucky"
def afficher_design():
    print("\n")
    print("**************************************")
    print("**       Bienvenue dans Tsoucky    **")
    print("**       Menu Principal            **")
    print("**************************************")
    print("\n")
    print("    TTTTT  SSSS  OOO  U   U  CCCC  K   K  Y   Y")
    print("      T    S     O   O U   U C      K  K    Y Y")
    print("      T    SSS   O   O U   U C      KKK      Y")
    print("      T      S   O   O U   U C      K  K     Y")
    print("      T    SSSS   OOO   UUU  CCCC  K   K    Y")
    print("\n")
    print("Création d'IA Tsoucky")
    print("\n")

# Fonction pour afficher le menu principal
def afficher_menu():
    print("Choisissez une option:")
    print("1. Lancer Tsoucky-Noob (IA qui apprend par elle-même)")
    print("2. Lancer Tsoucky-Noob avec envoi d'emails")
    print("3. Quitter")

# Fonction pour charger la base de connaissances (si elle existe)
def charger_connaissances():
    if os.path.exists("knowledge.base"):
        with open("knowledge.base", "r", encoding="utf-8") as f:
            return json.load(f)
    return {}

# Fonction pour sauvegarder la base de connaissances
def sauvegarder_connaissances(knowledge_base):
    with open("knowledge.base", "w", encoding="utf-8") as f:
        json.dump(knowledge_base, f, ensure_ascii=False, indent=4)

# Fonction pour normaliser les questions (mettre en minuscule et enlever les accents)
def normaliser_texte(texte):
    # Convertir en minuscules
    texte = texte.lower()
    # Enlever les accents
    texte = ''.join(c for c in unicodedata.normalize('NFD', texte) if unicodedata.category(c) != 'Mn')
    return texte

# Fonction pour initialiser des réponses de base (salut, comment ça va, etc.)
def initialiser_reponses_de_base():
    return {
        "salut": "Salut ! Comment puis-je t'aider aujourd'hui ?",
        "ça va ?": "Ça va bien, merci ! Et toi, comment ça va ?",
        "qui es-tu ?": "Je suis Tsoucky-Noob, ton assistant IA qui apprend de toi !",
        "quel est ton nom ?": "Je m'appelle Tsoucky-Noob. Et toi ?",
        "comment ça va ?": "Ça va très bien, merci ! Et toi ?",
        "merci": "De rien, c'est un plaisir de t'aider !",
        "au revoir": "Au revoir et à bientôt !",
        "je t'aime": "Oh, c'est gentil ! Je t'aime aussi, en tant qu'IA bien sûr !",
        "hello": "Hello ! How can I help you today?"
    }

# Fonction pour envoyer l'email
def send_email(to_email, sender_email, password, subject, body):
    smtp_server = "smtp.gmail.com"
    smtp_port = 587

    # Création de l'email
    message = MIMEMultipart()
    message["From"] = sender_email
    message["To"] = to_email
    message["Subject"] = subject

    # Ajout du corps du message
    message.attach(MIMEText(body, "plain"))

    try:
        # Connexion au serveur SMTP
        with smtplib.SMTP(smtp_server, smtp_port) as server:
            server.starttls()  # Démarre une connexion sécurisée
            server.login(sender_email, password)  # Authentification
            text = message.as_string()
            server.sendmail(sender_email, to_email, text)  # Envoi de l'email
            print(f"Email envoyé à {to_email}")
    except Exception as e:
        print(f"Erreur lors de l'envoi de l'email à {to_email}: {e}")

# Fonction pour envoyer des emails à une fréquence
def envoyer_emails():
    sender_email = "ton_email@gmail.com"  # Remplace avec ton email
    password = "ton_mot_de_passe"  # Remplace avec ton mot de passe ou mot de passe d'application
    recipients = ["user1@example.com", "user2@example.com"]  # Remplace avec tes destinataires
    subject = "Sujet de l'email"
    body = "Bonjour, ceci est un message envoyé par Python !"

    # Fréquence d'envoi (en secondes)
    frequency = 10  # 10 secondes entre chaque email
    duration = 60  # Durée de l'envoi en secondes (par exemple 60 secondes = 1 minute)
    end_time = time.time() + duration

    while time.time() < end_time:
        for recipient in recipients:
            send_email(recipient, sender_email, password, subject, body)
            time.sleep(frequency)  # Attente entre chaque envoi

# Fonction pour résoudre les problèmes mathématiques de base
def resoudre_operation(question):
    try:
        # Évaluer la question mathématique et retourner le résultat
        result = eval(question)
        return f"Le résultat est : {result}"
    except Exception as e:
        return f"Désolé, je n'ai pas pu résoudre cette opération. Erreur : {e}"

# Fonction pour trouver la question la plus proche dans la base de connaissances
def trouver_question_proche(question, knowledge_base):
    questions_possibles = list(knowledge_base.keys())
    meilleur_match = process.extractOne(question, questions_possibles)
    return meilleur_match

# Fonction pour Tsoucky-Noob
def tsoucky_noob():
    knowledge_base = charger_connaissances()
    print("\nBienvenue dans Tsoucky-Noob !")
    print("Je vais t'aider de la manière suivante : Si je ne sais pas la réponse, je vais te demander de m'apprendre.")
    print("Si tu veux quitter, tape 'exit'.")

    while True:
        print("\nComment puis-je t'aider ?")
        question = input(": ")

        if question.lower() == 'exit':
            print("Merci de m'avoir appris, au revoir !")
            break

        # Normaliser la question entrée
        question_normalisee = normaliser_texte(question)

        # Si la question concerne une opération mathématique
        if any(char in question for char in "+-*/%"):
            print(resoudre_operation(question))
        # Si la question a déjà été posée et que Tsoucky-Noob connaît la réponse
        elif question_normalisee in knowledge_base:
            print(f"Tsoucky-Noob : {knowledge_base[question_normalisee]}")
        else:
            match = trouver_question_proche(question_normalisee, knowledge_base)
            if match[1] > 80:  # Si la similarité est suffisante, répondre avec la meilleure correspondance
                print(f"Tsoucky-Noob : Je crois que tu parles de : {match[0]}. Voici la réponse : {knowledge_base[match[0]]}")
            else:
                print("Tsoucky-Noob : Je ne sais pas cela encore. Peux-tu m'apprendre la réponse ?")
                reponse = input("Ta réponse : ")
                knowledge_base[question_normalisee] = reponse
                sauvegarder_connaissances(knowledge_base)
                print("Tsoucky-Noob : Merci, je vais me souvenir de cela !")

# Fonction principale
def main():
    clear_screen()
    afficher_design()

    while True:
        afficher_menu()
        choix = input("\nEntrez votre choix : ")

        if choix == '1':
            tsoucky_noob()
        elif choix == '2':
            envoyer_emails()  # Envoi des emails dans l'option 2
            tsoucky_noob()  # Ensuite, lancer Tsoucky-Noob après l'envoi des emails
        elif choix == '3':
            print("Au revoir !")
            break
        else:
            print("Choix invalide. Veuillez réessayer.")

if __name__ == "__main__":
    main()